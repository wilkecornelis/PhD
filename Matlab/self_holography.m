%% Self-holography of MFAA
%
% This script studies the possibility to calibrate an MFAA station using
% self-holography, i.e., by inferring the tile-level gains from correlation
% of the tile signals against a reference beam produced by the station
% itself.
%
% SJW, 25 May 2017

%% start with a clean workspace
clear
close all

%% define scenario
N = 391 * 256;              % about 1e5 antennas in a station
pitch = 0.125;              % antenna pitch in m
Tsys = 35;                  % system temperature in K
Dir = 4;                    % directivity of individual array elements
Nelem = [2, 4, 8, 16].^2;   % number of elements within a tile
f = 1e9;                    % observing frequency in Hz
c = 2.99792e8;              % speed of light in m/s
kB = 1.38e-23;              % Boltzmann constant in J/K
B = 10e6;                   % integration bandwidth in Hz
tau = 10;                   % integration bandwidth in s
Niter = 20;                 % number of iterations in calibration
Nrun = 100;                 % number of runs in MC sim

%% Monte Carlo simulation

% determine the number of tiles within a station
Ntile = floor(N ./ Nelem);
% calculate actual number of elements in a station after rounding
Nstat = Ntile .* Nelem;
% determine the sensitivity of tile-station baseline
lambda = c / f;
Ae_elem = min(lambda^2 * Dir / (4 * pi), pitch^2);
% pre-calculate source density
fluxlim = logspace(-6, 3, 1000);
rhosrc = srcstat(fluxlim, f);
calflux = zeros(length(Ntile), 1);
SNRcal = zeros(length(Ntile), 1);
SNR = zeros(length(Ntile), 1);
delta = zeros(Niter, length(Ntile), Nrun);
dphase = zeros(Niter, length(Ntile), Nrun);
dampl = zeros(Niter, length(Ntile), Nrun);
g0 = zeros(100, length(Ntile), Nrun);
ghat = zeros(100, length(Ntile), Nrun);
for run = 1:Nrun;
    tic
for idx = 1:length(Ntile)
    Ae_tile = Nelem(idx) * Ae_elem;
    Ae_stat = Nstat(idx) * Ae_elem;
    % SEFD in Jy (I guess, noise power generated by the system?)
    dS = 1e26 * 2 * kB * Tsys / sqrt(Ae_tile * Ae_stat);
    % determine flux at with one source within HPBW
    Dtile = sqrt(Nelem(idx)) * pitch;
    HPBW = lambda / Dtile;
    FoV = 0.25 * pi * HPBW^2;
%    FoV = 2 * pi; % all-sky FoV
    Nsrc = rhosrc * FoV;
    calflux(idx) = interp1(Nsrc, fluxlim, 1);
    % calculate SNR of calibration signal
    SNRcal(idx) = calflux(idx) / dS;
    % calculate SNR per element
    dSelem = 1e26 * 2 * kB * Tsys / Ae_elem;
    SNR(idx) = calflux(idx) / dSelem;
    
    % simulate calibration
    sigmacal = 1;   % flux of calibrator in arbitrary units
    gtrue = ones(Ntile(idx), 1) + 0.1 * (randn(Ntile(idx), 1) + 1i * randn(Ntile(idx), 1));     % true (complex) gain values

    ginit = ones(Ntile(idx), 1);     % initial estimates for gains
    for iter = 1:Niter
        wref = (ones(Ntile(idx), 1) / Ntile(idx)) ./ conj(ginit);
        %R = gtrue * gtrue' * Nelem(idx)^2 * sigmacal + Nelem(idx) * (sigmacal / SNR(idx)) * eye(Ntile(idx));
        r = gtrue * (wref' * gtrue) * Nelem(idx)^2 * sigmacal + wref * Nelem(idx) * (sigmacal / SNR(idx));
        %rtest = R * wref;
        %ryytest = wref' * R * wref;
        ryy = abs(wref' * gtrue)^2 * Nelem(idx)^2 * sigmacal + (wref' * wref) * Nelem(idx) * (sigmacal / SNR(idx));
        %gdiff = (rtest / ryy);
        gest = (r / ryy);
        %gest(:, iter) = gdiff .* ginit;
        delta(iter, idx, run) = norm(gtrue - gest) / norm(gest);
        dphase(iter, idx, run) = mean(abs(angle(gtrue) - angle(gest)));
        dampl(iter, idx, run) = mean(abs(abs(gtrue) - abs(gest)));
        ginit = gest;
    end
    ghat(:, idx, run) = ginit(1:100);
    g0(:, idx, run) = gtrue(1:100);
end
    toc
end

%% show results
close all

%%
figure
semilogy(1:Niter, mean(dphase, 3));
set(gca, 'FontSize', 16);
xlabel('iteration number');
ylabel('\Delta_{phase} (rad)');
legendinfo = {['P = ' num2str(Ntile(1)) ' (M = ' num2str(Nelem(1)) ')'], ...
              ['P = ' num2str(Ntile(2)) ' (M = ' num2str(Nelem(2)) ')'], ...
              ['P = ' num2str(Ntile(3)) ' (M = ' num2str(Nelem(3)) ')'], ...
              ['P = ' num2str(Ntile(4)) ' (M = ' num2str(Nelem(4)) ')']};
legend(legendinfo, 'Location', 'SouthWest');

%%
figure
plot(1:Niter, mean(dampl, 3));
set(gca, 'FontSize', 16);
xlabel('iteration number');
ylabel('\Delta_{ampl} (rad)');
legend(legendinfo, 'Location', 'SouthEast');

%%
figure
loglog(Nelem, SNRcal * sqrt(B * tau), 'b-', ...
       Nelem, SNRcal, 'b--', ...
       Nelem, SNR * sqrt(B * tau), 'r-', ...
       Nelem, SNR, 'r--');
set(gca, 'Fontsize', 16);
xlabel('number of elements per tile');
ylabel('SNR');
set(gca, 'XTick', Nelem, 'XTickLabel', num2str(Nelem.'))
%legend('SNR of {\bf r}/{r_yy} after integration', ...
%       'SNR of {\bf r}/{r_yy} before integration', ...
%       'SNR per element after integration', ...
%       'SNR per element before integration');

figure
plot(Ntile.^0.6, calflux)
set(gca, 'FontSize', 16)
xlabel('P^{0.6}');
ylabel('typical calibrator flux (Jy)');

% plot of ratio of first and second term in numerator / denominator
term1 = Nelem.'.^2;
term2 = Nelem.' .* (1 ./ SNR) ./ Ntile.';
figure
plot(Ntile.^-0.4, (term1 ./ term2))
set(gca, 'FontSize', 16);
xlabel('P^{-0.4}');
ylabel('ratio of terms');-

% plot comparison of gain solutions
figure
subplot(2, 1, 1);
plot(1:100, abs(g0(:, 1, 1)), '-', ...
     1:100, abs(ghat(:, 1, 1)), '-');
%     1:100, abs(ghat(:, 1, 1)) +  (abs(ghat(:, 1, 1)) - 1));
set(gca, 'FontSize', 16);
xlabel('tile index');
ylabel('gain amplitude');
legend('true gain amplitude', 'estimated gain amplitude'); %, 'after scaling difference from unity');

subplot(2, 1, 2);
plot(1:100, angle(g0(:, 1, 1)), '-', ...
     1:100, angle(ghat(:, 1, 1)), 'o');
set(gca, 'FontSize', 16);
xlabel('tile index');
ylabel('gain phase (rad)');
legend('true gain phase', 'estimated gain phase');

